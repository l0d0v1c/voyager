<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Voyager 2 AR + iOS Permission + Flèche</title>
  <style>
    /* ----------- Style principal ----------- */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: linear-gradient(to right, #89f7fe, #66a6ff);
      position: relative;
    }

    header {
      position: absolute;
      top: 0; left: 0; right: 0;
      text-align: center;
      padding: 10px;
      background: rgba(255, 255, 255, 0.6);
      z-index: 10;
    }

    /* ----------- Bouton iOS plein écran ----------- */
    #btn-orientation {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      z-index: 9999;
      font-size: 22px;
      color: #333;
      text-align: center;
      border: none;
      cursor: pointer;
    }

    /* ----------- Zone "scène" plein écran ----------- */
    #scene {
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: hidden;
    }

    /* ----------- Croix (cible AR) ----------- */
    #target {
      position: absolute;
      width: 40px;
      height: 40px;
      background: none;
      border: 2px solid red;
      border-radius: 50%;
      transform: translate(-20px, -20px);
      pointer-events: none;
    }
    #target::before, #target::after {
      content: '';
      position: absolute;
      background: red;
    }
    #target::before {
      top: 50%; left: 0;
      width: 100%; height: 2px;
      transform: translateY(-50%);
    }
    #target::after {
      left: 50%; top: 0;
      width: 2px; height: 100%;
      transform: translateX(-50%);
    }

    /* ----------- Flèche (compas) au centre ----------- */
    #arrow {
      position: absolute;
      top: 50%; left: 50%;
      width: 0; height: 0;
      transform: translate(-50%, -50%);
      /* On dessine un triangle pointant vers le haut (border technique) */
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-bottom: 30px solid limegreen;
      /* On peut ajuster la taille/couleur à volonté */
      z-index: 999;
      pointer-events: none;
    }

    /* ----------- Panneau d'informations ----------- */
    #info {
      position: absolute;
      bottom: 0; left: 0; right: 0;
      background: rgba(255, 255, 255, 0.75);
      padding: 10px;
      font-size: 14px;
    }
    #info p {
      margin: 0;
      line-height: 1.4em;
    }
  </style>
</head>
<body>
  <header>
    <h2>Voyager 2 AR Demo (Flèche + Croix)</h2>
  </header>

  <!-- Bouton pour autoriser l'orientation (plein écran) -->
  <button id="btn-orientation">
    Cliquer pour autoriser l'orientation<br/>
    (iOS 13+ / Safari)
  </button>

  <!-- Zone "scène" avec la croix AR -->
  <div id="scene">
    <!-- La croix rouge représentant la direction “exacte” de Voyager 2 en AR -->
    <div id="target"></div>
    <!-- Flèche (compas) toujours au centre -->
    <div id="arrow"></div>
  </div>

  <!-- Zone d'infos en bas (GPS, orientation, position V2) -->
  <div id="info">
    <p><strong>Orientation téléphone</strong> : <span id="orient-data">En attente…</span></p>
    <p><strong>Position phone (lat, lon, alt)</strong> : <span id="gps-data">En attente…</span></p>
    <p><strong>Position Voyager 2 (Ecl. J2000)</strong> : <span id="v2-data">?</span></p>
  </div>

  <script>
    /***********************************************
     * 0) Constantes / utilitaires math
     ***********************************************/
    const deg2rad = Math.PI / 180;

    function geodeticToEcliptic(latDeg, lonDeg, altMeters = 0) {
      // Simplifié : lat/lon -> ECEF -> rotation obliquité => ecliptique
      const lat = latDeg * deg2rad;
      const lon = lonDeg * deg2rad;
      const a = 6378.137; // demi-grand axe Terre (km)
      const e2 = 6.69437999014e-3;
      const altKm = altMeters / 1000;

      const sinLat = Math.sin(lat);
      const cosLat = Math.cos(lat);
      const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);

      const xECEF = (N + altKm) * cosLat * Math.cos(lon);
      const yECEF = (N + altKm) * cosLat * Math.sin(lon);
      const zECEF = (N*(1 - e2) + altKm) * sinLat;

      // Rotation approx. -23.4393° autour de X
      const eps = -23.4393 * deg2rad;
      const cosEps = Math.cos(eps);
      const sinEps = Math.sin(eps);

      const xEcl = xECEF;
      const yEcl = yECEF * cosEps - zECEF * sinEps;
      const zEcl = yECEF * sinEps + zECEF * cosEps;

      return { x: xEcl, y: yEcl, z: zEcl };
    }

    const Vec3 = {
      sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }),
      length: (v) => Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z),
      normalize: (v) => {
        const len = Vec3.length(v);
        return len ? { x: v.x/len, y: v.y/len, z: v.z/len } : { x:0, y:0, z:0 };
      }
    };

    /***********************************************
     * 1) Récupération position de Voyager 2
     ***********************************************/
    let v2PosEcl = null;

    async function fetchVoyagerPosition() {
      try {
        const resp = await fetch('https://voyager.org.men/voyager2.php');
        const text = await resp.text();

        // Extraction du bloc $$SOE ... $$EOE
        const soeIdx = text.indexOf('$$SOE');
        const eoeIdx = text.indexOf('$$EOE');
        if (soeIdx < 0 || eoeIdx < 0) throw new Error("Bloc $$SOE/$$EOE introuvable");

        const dataBlock = text.substring(soeIdx + 5, eoeIdx).trim();
        const lines = dataBlock.split('\n').map(l => l.trim()).filter(l => l.length > 0);

        // On prend le premier chunk
        let firstChunk = [];
        let inChunk = false;
        for (const line of lines) {
          if (line.includes('= A.D.')) {
            if (inChunk) break; // on avait déjà un chunk
            firstChunk.push(line);
            inChunk = true;
          } else if (inChunk) {
            firstChunk.push(line);
          }
        }

        // Parse
        function parseTriplet(str, keys=['X','Y','Z']) {
          const out = {};
          keys.forEach(k => {
            const re = new RegExp(`${k}\\s*=\\s*([+\\-0-9.E]+)`);
            const m = str.match(re);
            if (m) out[k] = parseFloat(m[1]);
          });
          return out;
        }
        const xyzLine = firstChunk.find(l => l.startsWith('X =') || l.startsWith('X='));
        if (!xyzLine) throw new Error("Impossible de trouver la ligne X= ... Y= ... Z=");
        const xyz = parseTriplet(xyzLine);

        v2PosEcl = { x: xyz.X, y: xyz.Y, z: xyz.Z };
        document.getElementById('v2-data').textContent = 
          `(${xyz.X.toExponential(3)}, ${xyz.Y.toExponential(3)}, ${xyz.Z.toExponential(3)}) km`;
      } catch(e) {
        console.error(e);
        document.getElementById('v2-data').textContent = "Erreur : " + e;
      }
    }

    /***********************************************
     * 2) Position & Orientation du téléphone
     ***********************************************/
    let phonePosEcl = { x:0, y:0, z:0 };
    let phoneHeading = 0; // alpha
    let phonePitch = 0;   // beta
    let phoneRoll = 0;    // gamma

    // 2.1) Géolocalisation
    navigator.geolocation?.getCurrentPosition(
      (pos) => {
        const { latitude, longitude, altitude } = pos.coords;
        const altOk = altitude || 0;
        phonePosEcl = geodeticToEcliptic(latitude, longitude, altOk);
        document.getElementById('gps-data').textContent =
          `${latitude.toFixed(5)}°, ${longitude.toFixed(5)}°, alt=${altOk.toFixed(1)} m`;
      },
      (err) => {
        console.warn("Géoloc refusée ou indisponible.", err);
        document.getElementById('gps-data').textContent = "Géoloc refusée ou indispo.";
      },
      { enableHighAccuracy: true, timeout: 15000 }
    );

    // 2.2) Autorisation orientation iOS (bouton)
    function startDeviceOrientation() {
      window.addEventListener('deviceorientation', (event) => {
        phoneHeading = event.alpha ?? 0;
        phonePitch = event.beta ?? 0;
        phoneRoll = event.gamma ?? 0;
        document.getElementById('orient-data').textContent =
          `alpha=${phoneHeading.toFixed(1)}, beta=${phonePitch.toFixed(1)}, gamma=${phoneRoll.toFixed(1)}`;
      }, true);
    }

    async function requestOrientationPermission() {
      // iOS 13+
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const resp = await DeviceOrientationEvent.requestPermission();
          if (resp === 'granted') {
            startDeviceOrientation();
            // Cache le bouton
            document.getElementById('btn-orientation').style.display = 'none';
          } else {
            alert("Permission refusée ou ignorée.");
          }
        } catch(e) {
          console.error("Erreur requestPermission:", e);
        }
      } else {
        // Android ou iOS < 13
        startDeviceOrientation();
        document.getElementById('btn-orientation').style.display = 'none';
      }
    }

    /***********************************************
     * 3) AR simplifiée : la croix & la flèche
     ***********************************************/
    const sceneEl = document.getElementById('scene');
    const targetEl = document.getElementById('target');
    const arrowEl  = document.getElementById('arrow');

    function animate() {
      requestAnimationFrame(animate);
      if (!v2PosEcl) return;

      // Vecteur phone->V2
      const phoneToV2 = Vec3.sub(v2PosEcl, phonePosEcl);
      const dir = Vec3.normalize(phoneToV2);

      // On calcule un azimut/élévation simplifié (0°=+Y)
      const az = Math.atan2(dir.x, dir.y);
      const el = Math.asin(dir.z);

      // Orientation phone
      const headingRad = phoneHeading * deg2rad; // alpha
      const pitchRad   = phonePitch  * deg2rad;  // beta

      // Ecart d'azimut
      let relAz = az - headingRad;
      // Ramène relAz dans [-pi, pi]
      if (relAz > Math.PI) relAz -= 2*Math.PI;
      if (relAz < -Math.PI) relAz += 2*Math.PI;

      // Ecart d'élévation
      let relEl = el - (-pitchRad); // pitch>0 => penché vers le bas

      // ---- 3.1) Affichage de la CROIX ----
      const FOVx = 0.6;   // ~60° horizontal
      const FOVy = 0.45;  // ~45° vertical
      const rx = relAz / (FOVx/2);
      const ry = -(relEl / (FOVy/2)); // inversion sur Y

      const scrW = sceneEl.clientWidth;
      const scrH = sceneEl.clientHeight;

      let px = scrW/2 + (scrW/2)*rx;
      let py = scrH/2 + (scrH/2)*ry;

      // Borne la croix à l'écran
      if (px < 20) px = 20;
      if (px > scrW - 20) px = scrW - 20;
      if (py < 20) py = 20;
      if (py > scrH - 20) py = scrH - 20;

      targetEl.style.left = px + 'px';
      targetEl.style.top  = py + 'px';

      // ---- 3.2) Affichage de la FLECHE (compas) ----
      // On souhaite que la flèche pointe "en haut" (0° de rotation) quand relAz=0
      // => arrowAngle = -relAz (en degrés)
      const arrowDeg = -(relAz * 180 / Math.PI);
      arrowEl.style.transform = `translate(-50%, -50%) rotate(${arrowDeg}deg)`;
      // On garde la flèche toujours au centre de l'écran
    }

    // Lancement de la boucle
    requestAnimationFrame(animate);

    /***********************************************
     * 4) Initialisation
     ***********************************************/
    document.getElementById('btn-orientation').addEventListener('click', () => {
      requestOrientationPermission();
    });

    // On charge la position de V2
    fetchVoyagerPosition();
  </script>
</body>
</html>