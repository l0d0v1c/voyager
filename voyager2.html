<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Voyager 2 - Coordonnées</title>
  <style>
    /* =========================
       STYLES GLOBAUX
       ========================= */
    html, body {
      margin: 0; padding: 0;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: linear-gradient(to right, #89f7fe, #66a6ff);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header, main, footer {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }
    header {
      text-align: center;
      padding: 20px 0;
      color: #333;
    }
    header h1 {
      margin: 0;
      font-size: 2rem;
      font-weight: 600;
    }
    footer {
      text-align: center;
      margin-top: auto;
      padding: 10px 0;
      color: #444;
    }
    /* =========================
       CONTENEUR PRINCIPAL
       ========================= */
    #data-container {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      margin: 20px;
      padding: 20px;
      overflow-x: auto; /* Pour scroll horizontal si tableau large */
    }
    /* =========================
       TABLES
       ========================= */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      min-width: 900px; /* si on veut un min de large */
    }
    th, td {
      border: 1px solid #ccc;
      padding: 10px;
      text-align: right;
    }
    th {
      background-color: #fafafa;
      text-align: center;
    }
    tr:hover {
      background-color: #f5f5f5;
      transition: background-color 0.2s ease;
    }
    caption {
      caption-side: top;
      font-weight: bold;
      font-size: 1.1rem;
      text-align: left;
      margin-bottom: 8px;
    }
    .timestamp {
      text-align: center;
      font-weight: bold;
      color: #444;
    }
    .loading, .error {
      color: #555;
      font-style: italic;
    }
    .error {
      color: red;
    }
    /* =========================
       PETITES ANIMATIONS
       ========================= */
    .fade-in {
      animation: fadeIn 0.8s ease forwards;
      opacity: 0;
    }
    @keyframes fadeIn {
      to { opacity: 1; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Voyager 2 - Données JPL Horizons</h1>
  </header>

  <main>
    <div id="data-container">
      <p class="loading">Chargement des données en cours…</p>
    </div>
  </main>

  <footer>
    <small>Exemple démo - Conversion simplifiée</small>
  </footer>

  <script>
    /***********************************************************
     * 1) Fonction de conversion lat/lon/alt -> vecteur ecliptique (approx.)
     *    ---------------------------------------------------------------
     *   - On calcule d’abord le vecteur ECEF (équatorial, Terre rotée)
     *   - On applique ensuite une rotation ~ -23.44° sur l’axe X
     *     pour approx. passer du plan équatorial au plan écliptique.
     *   - NB: Ceci est simplifié : l’axe X n’est pas exactement
     *         l’axe d’inclinaison. En vrai, on doit tenir compte
     *         du temps sidéral, etc. Mais c’est déjà une démo indicative !
     ***********************************************************/
    function geodeticToEcliptic(latDeg, lonDeg, altMeters = 0) {
      // 1. Conversion degrés -> radians
      const lat = latDeg * Math.PI / 180.0;
      const lon = lonDeg * Math.PI / 180.0;
      // 2. Paramètres WGS84 approximés (en km)
      const a = 6378.137;             // demi-grand axe (km)
      const e2 = 6.69437999014e-3;    // excentricité²
      const altKm = altMeters / 1000; // altitude en km

      // 3. Rayon normal
      const sinLat = Math.sin(lat);
      const cosLat = Math.cos(lat);
      const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);

      // 4. Coordonnées ECEF (approx.)
      const xECEF = (N + altKm) * cosLat * Math.cos(lon);
      const yECEF = (N + altKm) * cosLat * Math.sin(lon);
      const zECEF = ((1 - e2) * N + altKm) * sinLat;

      // 5. Rotation ECEF -> Ecliptique (approx.)
      //    On fait pivoter autour de l'axe X de -23.4393° (obliquité)
      const eps = -23.4393 * Math.PI / 180.0;
      const cosEps = Math.cos(eps);
      const sinEps = Math.sin(eps);

      //  x' = x
      //  y' = y*cos(eps) - z*sin(eps)
      //  z' = y*sin(eps) + z*cos(eps)
      const xEcl = xECEF;
      const yEcl = yECEF * cosEps - zECEF * sinEps;
      const zEcl = yECEF * sinEps + zECEF * cosEps;

      return { xEcl, yEcl, zEcl };
    }

    /***********************************************************
     * 2) Récupération et parsing du fichier Horizons
     *    + Préparation des tableaux
     ***********************************************************/
    document.addEventListener('DOMContentLoaded', async () => {
      const container = document.getElementById('data-container');

      // Pour stocker la position locale (x,y,z) => déterminée plus tard
      let localPosEcliptic = { xEcl: 0, yEcl: 0, zEcl: 0 }; 
      let hasLocalPosition = false;

      try {
        // 2.1) On essaye de récupérer la géolocalisation depuis le navigateur
        //      (la requête sera async, on la laisse tourner en background)
        navigator.geolocation?.getCurrentPosition(
          (pos) => {
            const { latitude, longitude, altitude } = pos.coords;
            // altitude peut être null selon les navigateurs => on met 0 si manquante
            const altOk = altitude !== null ? altitude : 0;
            localPosEcliptic = geodeticToEcliptic(latitude, longitude, altOk);
            hasLocalPosition = true;
          },
          (err) => {
            console.warn('Géolocalisation refusée ou indisponible.', err);
          },
          { enableHighAccuracy: true, timeout: 5000 }
        );

        // 2.2) Récupération du contenu brut depuis l'URL
        const response = await fetch('https://voyager.org.men/voyager2.php');
        if (!response.ok) {
          throw new Error(`Erreur HTTP : ${response.status}`);
        }
        const rawText = await response.text();

        // 2.3) Extraction du bloc entre $$SOE et $$EOE
        const soeIndex = rawText.indexOf('$$SOE');
        const eoeIndex = rawText.indexOf('$$EOE');
        if (soeIndex === -1 || eoeIndex === -1) {
          throw new Error('Impossible de trouver le bloc $$SOE ... $$EOE dans la réponse.');
        }
        const dataBlock = rawText.substring(soeIndex + 5, eoeIndex).trim();

        // 2.4) Séparer en “chunks” par date
        const lines = dataBlock
          .split('\n')
          .map(l => l.trim())
          .filter(l => l.length > 0);

        let chunks = [];
        let currentChunk = [];
        lines.forEach(line => {
          if (line.includes('= A.D.')) {
            // Nouveau bloc
            if (currentChunk.length > 0) chunks.push(currentChunk);
            currentChunk = [line];
          } else {
            currentChunk.push(line);
          }
        });
        if (currentChunk.length > 0) chunks.push(currentChunk);

        // 2.5) Parser chaque chunk
        function parseTriplet(lineStr, keys = ['X','Y','Z']) {
          let obj = {};
          if (!lineStr) return obj;
          keys.forEach(k => {
            const regex = new RegExp(`${k}\\s*=\\s*([+\\-0-9.E]+)`);
            const match = lineStr.match(regex);
            if (match) {
              obj[k] = parseFloat(match[1]);
            }
          });
          return obj;
        }
        const parsedData = chunks.map(ch => {
          // Ex: "2460677.916666667 = A.D. 2025-Jan-02 10:00:00.0000 TDB"
          const [jdPart, datePart] = ch[0].split('=').map(x => x.trim());
          const julianDay = jdPart;
          const dateTDB = datePart.replace('TDB', '').trim();

          const xyzLine = ch.find(l => l.startsWith('X =') || l.startsWith('X='));
          const vxvyvzLine = ch.find(l => l.startsWith('VX='));
          const ltrgrrLine = ch.find(l => l.startsWith('LT='));

          const xyz = parseTriplet(xyzLine, ['X','Y','Z']);
          const vxyz = parseTriplet(vxvyvzLine, ['VX','VY','VZ']);
          const others = parseTriplet(ltrgrrLine, ['LT','RG','RR']);

          return {
            julianDay,
            dateTDB,
            ...xyz,
            ...vxyz,
            ...others
          };
        });

        // 3) Construction des deux tableaux
        //    ------------------------------
        //    (A) Tableau centré Terre (0,0,0)
        //    (B) Tableau centré sur l’observateur local (approx.)
        let html = '<div class="fade-in">';

        // 3A) Tableau #1 : Positions centrées Terre (comme Horizons le fournit)
        html += `
          <table>
            <caption>Coordonnées : Observateur à (lat=0, lon=0, alt=0)</caption>
            <thead>
              <tr>
                <th>Date TDB (JD)</th>
                <th>Date (calendaire)</th>
                <th>X (km)</th>
                <th>Y (km)</th>
                <th>Z (km)</th>
                <th>VX (km/s)</th>
                <th>VY (km/s)</th>
                <th>VZ (km/s)</th>
                <th>LT (s)</th>
                <th>RG (km)</th>
                <th>RR (km/s)</th>
              </tr>
            </thead>
            <tbody>
        `;
        parsedData.forEach(row => {
          html += `
            <tr>
              <td class="timestamp">${row.julianDay}</td>
              <td class="timestamp">${row.dateTDB}</td>
              <td>${row.X?.toExponential(6)}</td>
              <td>${row.Y?.toExponential(6)}</td>
              <td>${row.Z?.toExponential(6)}</td>
              <td>${row.VX?.toFixed(6)}</td>
              <td>${row.VY?.toFixed(6)}</td>
              <td>${row.VZ?.toFixed(6)}</td>
              <td>${row.LT?.toFixed(2)}</td>
              <td>${row.RG?.toExponential(6)}</td>
              <td>${row.RR?.toFixed(6)}</td>
            </tr>
          `;
        });
        html += `</tbody></table>`;

        // 3B) Tableau #2 : Si on dispose de la position locale => position relative
        html += `
          <table>
            <caption>Coordonnées : Observateur local (GPS) <br/>
              <small style="font-weight:normal;">
                (Approx. conversion lat/lon/alt -> ecliptique J2000)
              </small>
            </caption>
            <thead>
              <tr>
                <th>Date TDB (JD)</th>
                <th>Date (calendaire)</th>
                <th>X' (km)</th>
                <th>Y' (km)</th>
                <th>Z' (km)</th>
              </tr>
            </thead>
            <tbody>
        `;

        parsedData.forEach(row => {
          // On soustrait (xObs, yObs, zObs) => (X', Y', Z') = (X - xObs, Y - yObs, Z - zObs)
          // NB: S’il n’y a pas de position locale, on mettra '---'.
          let Xprime = '---', Yprime = '---', Zprime = '---';
          if (hasLocalPosition) {
            Xprime = (row.X - localPosEcliptic.xEcl).toExponential(6);
            Yprime = (row.Y - localPosEcliptic.yEcl).toExponential(6);
            Zprime = (row.Z - localPosEcliptic.zEcl).toExponential(6);
          }

          html += `
            <tr>
              <td class="timestamp">${row.julianDay}</td>
              <td class="timestamp">${row.dateTDB}</td>
              <td>${Xprime}</td>
              <td>${Yprime}</td>
              <td>${Zprime}</td>
            </tr>
          `;
        });
        html += `</tbody></table></div>`;

        // On insère le tout dans la page
        container.innerHTML = html;

      } catch (error) {
        container.innerHTML = `<p class="error">Erreur lors du chargement ou parsing des données : ${error}</p>`;
        console.error(error);
      }
    });
  </script>
</body>
</html>